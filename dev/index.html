<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction ¬∑ TransformVariables.jl</title><meta name="title" content="Introduction ¬∑ TransformVariables.jl"/><meta property="og:title" content="Introduction ¬∑ TransformVariables.jl"/><meta property="twitter:title" content="Introduction ¬∑ TransformVariables.jl"/><meta name="description" content="Documentation for TransformVariables.jl."/><meta property="og:description" content="Documentation for TransformVariables.jl."/><meta property="twitter:description" content="Documentation for TransformVariables.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TransformVariables.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#General-interface"><span>General interface</span></a></li><li><a class="tocitem" href="#Transformations"><span>Transformations</span></a></li><li><a class="tocitem" href="#Inverses"><span>Inverses</span></a></li><li><a class="tocitem" href="#Integration-into-Bayesian-inference"><span>Integration into Bayesian inference</span></a></li><li><a class="tocitem" href="#Miscellaneous"><span>Miscellaneous</span></a></li><li class="toplevel"><a class="tocitem" href="#Defining-transformations"><span>Defining transformations</span></a></li><li><a class="tocitem" href="#The-as-constructor-and-aggregations"><span>The <code>as</code> constructor and aggregations</span></a></li><li><a class="tocitem" href="#Scalar-transforms"><span>Scalar transforms</span></a></li><li><a class="tocitem" href="#Special-arrays"><span>Special arrays</span></a></li><li><a class="tocitem" href="#Miscellaneous-transformations"><span>Miscellaneous transformations</span></a></li><li class="toplevel"><a class="tocitem" href="#Defining-custom-transformations"><span>Defining custom transformations</span></a></li></ul></li><li><a class="tocitem" href="internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/tpapp/TransformVariables.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/tpapp/TransformVariables.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>Some problems, especially in numerical integration and Markov Chain Monte Carlo, benefit from <em>transformation</em> of variables: for example, if <span>$œÉ &gt; 0$</span> is a standard deviation parameter, it is usually better to work with <code>log(œÉ)</code> which can take any value on the real line. However, in general such transformations require correcting density functions by the determinant of their Jacobian matrix, usually referred to as &quot;the Jacobian&quot;.</p><p>Also, is usually easier to code MCMC algorithms to work with vectors of real numbers, which may represent a &quot;flattened&quot; version of parameters, and would need to be decomposed into individual parameters, which themselves may be arrays, tuples, or special objects like lower triangular matrices.</p><p>This package is designed to help with both of these use cases. For example, consider the &quot;8 schools&quot; problem from Chapter 5.5 of Gelman et al (2013), in which SAT scores <span>$y_{ij}$</span> in <span>$J=8$</span> schools are modeled using a conditional normal</p><p class="math-container">\[y_{ij} ‚àº N(Œ∏‚±º, œÉ¬≤)\]</p><p>and the <span>$Œ∏‚±º$</span> are assume to have a hierarchical prior distribution</p><p class="math-container">\[Œ∏‚±º ‚àº N(Œº, œÑ¬≤)\]</p><p>For this problem, one could define a transformation</p><pre><code class="language-julia hljs">using TransformVariables
t = as((Œº = as‚Ñù, œÉ = as‚Ñù‚Çä, œÑ = as‚Ñù‚Çä, Œ∏s = as(Array, 8)))
dimension(t)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">11</code></pre><p>which would then yield a <code>NamedTuple</code> with the given names, with one of them being a <code>Vector</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = randn(dimension(t))</code><code class="nohighlight hljs ansi" style="display:block;">11-element Vector{Float64}:
  0.06193274031408013
  0.2784058141640002
 -0.5958244153640522
  0.04665938957338174
  1.0857940215432762
 -1.5765649225859841
  0.1759399913010747
  0.8653808054093252
  0.972024394360624
  1.546409924955377
 -0.5841980481085709</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = transform(t, x)</code><code class="nohighlight hljs ansi" style="display:block;">(Œº = 0.06193274031408013, œÉ = 1.3210221779582236, œÑ = 0.5511080366004918, Œ∏s = [0.04665938957338174, 1.0857940215432762, -1.5765649225859841, 0.1759399913010747, 0.8653808054093252, 0.972024394360624, 1.546409924955377, -0.5841980481085709])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; keys(y)</code><code class="nohighlight hljs ansi" style="display:block;">(:Œº, :œÉ, :œÑ, :Œ∏s)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y.Œ∏s</code><code class="nohighlight hljs ansi" style="display:block;">8-element Vector{Float64}:
  0.04665938957338174
  1.0857940215432762
 -1.5765649225859841
  0.1759399913010747
  0.8653808054093252
  0.972024394360624
  1.546409924955377
 -0.5841980481085709</code></pre><p>Further worked examples of using this package can be found in the <a href="https://github.com/tpapp/DynamicHMCExamples.jl/">DynamicHMCExamples.jl</a> repository. It is recommended that the user reads those first, and treats this documentation as a reference.</p><h1 id="General-interface"><a class="docs-heading-anchor" href="#General-interface">General interface</a><a id="General-interface-1"></a><a class="docs-heading-anchor-permalink" href="#General-interface" title="Permalink"></a></h1><h2 id="Transformations"><a class="docs-heading-anchor" href="#Transformations">Transformations</a><a id="Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="TransformVariables.dimension"><a class="docstring-binding" href="#TransformVariables.dimension"><code>TransformVariables.dimension</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dimension(t::AbstractTransform)</code></pre><p>The dimension (number of elements) that <code>t</code> transforms.</p><p>Types should implement this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/generic.jl#L267-L273">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.transform"><a class="docstring-binding" href="#TransformVariables.transform"><code>TransformVariables.transform</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">transform(t, x)</code></pre><p>Transform <code>x</code> using <code>t</code>.</p><pre><code class="nohighlight hljs">transform(t)</code></pre><p>Return a callable equivalent to <code>x -&gt; transform(t, x)</code> that transforms its argument:</p><pre><code class="language-julia hljs">transform(t, x) == transform(t)(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/generic.jl#L124-L136">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.transform_and_logjac"><a class="docstring-binding" href="#TransformVariables.transform_and_logjac"><code>TransformVariables.transform_and_logjac</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">transform_and_logjac(t, x)
</code></pre><p>Transform <code>x</code> using <code>t</code>; calculating the log Jacobian determinant, returned as the second value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/generic.jl#L318">source</a></section></details></article><h2 id="Inverses"><a class="docs-heading-anchor" href="#Inverses">Inverses</a><a id="Inverses-1"></a><a class="docs-heading-anchor-permalink" href="#Inverses" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="TransformVariables.inverse"><a class="docstring-binding" href="#TransformVariables.inverse"><code>TransformVariables.inverse</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">inverse(t, y)</code></pre><p>Return <code>x</code> so that <code>transform(t, x) ‚âà y</code>.</p><pre><code class="nohighlight hljs">inverse(t)</code></pre><p>Return a callable equivalent to <code>y -&gt; inverse(t, y)</code>. <code>t</code> can also be a callable created with transform, so the following holds:</p><pre><code class="language-julia hljs">inverse(t)(y) == inverse(t, y) == inverse(transform(t))(y)</code></pre><div class="admonition is-info" id="Note-62942627777855c1"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-62942627777855c1" title="Permalink"></a></header><div class="admonition-body"><p><code>eltype(inverse(t, transform(t, x)))</code> is not necessarily equal to <code>eltype(x)</code>, it is not guaranteed to be the narrowest possible type, and may change without warning between versions. Some effort is made to come up with a reasonable concrete type even in corner cases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/generic.jl#L155-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.inverse!"><a class="docstring-binding" href="#TransformVariables.inverse!"><code>TransformVariables.inverse!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">inverse!(x, transformation, y)
</code></pre><p>Put <code>inverse(t, y)</code> into a preallocated vector <code>x</code>, returning <code>x</code>.</p><p>Generalized indexing should be assumed on <code>x</code>.</p><p>See <a href="#TransformVariables.inverse_eltype"><code>inverse_eltype</code></a> for determining the type of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/generic.jl#L241">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.inverse_eltype"><a class="docstring-binding" href="#TransformVariables.inverse_eltype"><code>TransformVariables.inverse_eltype</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">inverse_eltype(t::AbstractTransform, y)
inverse_eltype(t::AbstractTransform, ::Type{T})</code></pre><p>The element type for vector <code>x</code> so that <code>inverse!(x, t, y::T)</code> works.</p><p><strong>Notes</strong></p><ol><li><p>It is not guaranteed that the result is the narrowest possible type, and may change without warning between versions. Some effort is made to come up with a reasonable concrete type even in corner cases.</p></li><li><p>Transformations should provide a method for <em>types</em>, not values.</p></li><li><p>No dimension or input compatibility checks are guaranteed to be performed, even for values.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/generic.jl#L214-L232">source</a></section></details></article><h2 id="Integration-into-Bayesian-inference"><a class="docs-heading-anchor" href="#Integration-into-Bayesian-inference">Integration into Bayesian inference</a><a id="Integration-into-Bayesian-inference-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-into-Bayesian-inference" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="TransformVariables.transform_logdensity"><a class="docstring-binding" href="#TransformVariables.transform_logdensity"><code>TransformVariables.transform_logdensity</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">transform_logdensity(t, f, x)
</code></pre><p>Let <span>$y = t(x)$</span>, and <span>$f(y)$</span> a log density at <code>y</code>. This function evaluates <code>f ‚àò t</code> as a log density, taking care of the log Jacobian correction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/generic.jl#L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.logprior"><a class="docstring-binding" href="#TransformVariables.logprior"><code>TransformVariables.logprior</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logprior(t, y)
</code></pre><p>Return the log prior correction used in <a href="#TransformVariables.transform_and_logjac"><code>transform_and_logjac</code></a>. The second argument is the output of a transformation.</p><p>The log jacobian determinant is corrected by this value, usually for the purpose of making a distribution proper. Can only be nonzero when <a href="#TransformVariables.nonzero_logprior"><code>nonzero_logprior</code></a> is true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/generic.jl#L176">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.nonzero_logprior"><a class="docstring-binding" href="#TransformVariables.nonzero_logprior"><code>TransformVariables.nonzero_logprior</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nonzero_logprior(t)
</code></pre><p>Return <code>true</code> only if there are potential inputs for which <a href="#TransformVariables.logprior"><code>logprior</code></a> is nonzero.</p><div class="admonition is-info" id="Note-d62aa9eabe66d1b8"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d62aa9eabe66d1b8" title="Permalink"></a></header><div class="admonition-body"><p>Currently the only transformation that has a log prior correction is <a href="#TransformVariables.unit_vector_norm"><code>unit_vector_norm</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/generic.jl#L188">source</a></section></details></article><h2 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="TransformVariables.domain_label"><a class="docstring-binding" href="#TransformVariables.domain_label"><code>TransformVariables.domain_label</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">domain_label(transformation, index)
</code></pre><p>Return a string that can be used to for identifying a coordinate. Mainly for debugging and generating graphs and data summaries.</p><p>Transformations may provide a heuristic label.</p><p>Transformations should implement <code>_domain_label</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = as((a = as‚Ñù‚Çä,
            b = as(Array, as‚Ñù‚Çã, 1, 1),
            c = corr_cholesky_factor(2)));

julia&gt; [domain_label(t, i) for i in 1:dimension(t)]
3-element Vector{String}:
 &quot;.a&quot;
 &quot;.b[1,1]&quot;
 &quot;.c[1]&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/generic.jl#L406">source</a></section></details></article><h1 id="Defining-transformations"><a class="docs-heading-anchor" href="#Defining-transformations">Defining transformations</a><a id="Defining-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-transformations" title="Permalink"></a></h1><h2 id="The-as-constructor-and-aggregations"><a class="docs-heading-anchor" href="#The-as-constructor-and-aggregations">The <code>as</code> constructor and aggregations</a><a id="The-as-constructor-and-aggregations-1"></a><a class="docs-heading-anchor-permalink" href="#The-as-constructor-and-aggregations" title="Permalink"></a></h2><p>Some transformations, particularly <em>aggregations</em> use the function <code>as</code> as the constructor. Aggregating transformations are built from other transformations to transform consecutive (blocks of) real numbers into the desired domain.</p><p>It is recommended that you use <code>as(Array, ...)</code> and friends (<code>as(Vector, ...)</code>, <code>as(Matrix, ...)</code>) for repeating the <em>same</em> transformation, and named tuples such as <code>as((Œº = ..., œÉ = ...))</code> for transforming into named parameters. For extracting parameters in log likelihoods, consider <a href="https://github.com/mauro3/Parameters.jl">Parameters.jl</a>.</p><p>See <code>methods(as)</code> for all the constructors, <code>?as</code> for their documentation.</p><article><details class="docstring" open="true"><summary id="TransformVariables.as"><a class="docstring-binding" href="#TransformVariables.as"><code>TransformVariables.as</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">as(T, args...)</code></pre><p>Shorthand for constructing transformations with image in <code>T</code>. <code>args</code> determines or modifies behavior, details depend on <code>T</code>.</p><p>Not all transformations have an <code>as</code> method, some just have direct constructors. See <code>methods(as)</code> for a list.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">as(Real, -‚àû, 1)          # transform a real number to (-‚àû, 1)
as(Array, 10, 2)         # reshape 20 real numbers to a 10x2 matrix
as(Array, asùïÄ, 10)       # transform 10 real numbers to (0, 1)
as((a = as‚Ñù‚Çä, b = asùïÄ)) # transform 2 real numbers a NamedTuple, with a &gt; 0, 0 &lt; b &lt; 1
as(SArray{1,2,3}, asùïÄ)  # transform to a static array of positive numbers</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/generic.jl#L276-L294">source</a></section></details></article><h2 id="Scalar-transforms"><a class="docs-heading-anchor" href="#Scalar-transforms">Scalar transforms</a><a id="Scalar-transforms-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-transforms" title="Permalink"></a></h2><p>The symbol <code>‚àû</code> is a placeholder for infinity. It does not correspond to <code>Inf</code>, but acts as a placeholder for the correct dispatch. <code>-‚àû</code> is valid.</p><article><details class="docstring" open="true"><summary id="TransformVariables.‚àû"><a class="docstring-binding" href="#TransformVariables.‚àû"><code>TransformVariables.‚àû</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><section><div><p>Placeholder representing of infinity for specifing interval boundaries. Supports the <code>-</code> operator, ie <code>-‚àû</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/scalar.jl#L197-L200">source</a></section></details></article><p><code>as(Real, a, b)</code> defines transformations to finite and (semi-)infinite subsets of the real line, where <code>a</code> and <code>b</code> can be <code>-‚àû</code> and <code>‚àû</code>, respectively.</p><article><details class="docstring" open="true"><summary id="TransformVariables.as-Tuple{Type{Real}, Any, Any}"><a class="docstring-binding" href="#TransformVariables.as-Tuple{Type{Real}, Any, Any}"><code>TransformVariables.as</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">as(Real, left, right)</code></pre><p>Return a transformation that transforms a single real number to the given (open) interval.</p><p><code>left &lt; right</code> is required, but may be <code>-‚àû</code> or <code>‚àû</code>, respectively, in which case the appropriate transformation is selected. See <a href="#TransformVariables.‚àû"><code>‚àû</code></a>.</p><p>Some common transformations are predefined as constants, see <a href="#TransformVariables.as‚Ñù"><code>as‚Ñù</code></a>, <a href="#TransformVariables.as‚Ñù‚Çã"><code>as‚Ñù‚Çã</code></a>, <a href="#TransformVariables.as‚Ñù‚Çä"><code>as‚Ñù‚Çä</code></a>, <a href="#TransformVariables.asùïÄ"><code>asùïÄ</code></a>.</p><div class="admonition is-info" id="Note-a992ec8989ca0ac3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a992ec8989ca0ac3" title="Permalink"></a></header><div class="admonition-body"><p>The finite arguments are promoted to a common type and affect promotion. Eg <code>transform(as(0, ‚àû), 0f0) isa Float32</code>, but <code>transform(as(0.0, ‚àû), 0f0) isa Float64</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/scalar.jl#L207-L222">source</a></section></details></article><p>The following constants are defined for common cases.</p><article><details class="docstring" open="true"><summary id="TransformVariables.as‚Ñù"><a class="docstring-binding" href="#TransformVariables.as‚Ñù"><code>TransformVariables.as‚Ñù</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><section><div><p>Transform to the real line (identity). See <a href="#TransformVariables.as"><code>as</code></a>.</p><p><code>as‚Ñù</code> and <code>as_real</code> are equivalent alternatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/scalar.jl#L265-L269">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.as‚Ñù‚Çä"><a class="docstring-binding" href="#TransformVariables.as‚Ñù‚Çä"><code>TransformVariables.as‚Ñù‚Çä</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><section><div><p>Transform to a positive real number. See <a href="#TransformVariables.as"><code>as</code></a>.</p><p><code>as‚Ñù‚Çä</code> and <code>as_positive_real</code> are equivalent alternatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/scalar.jl#L238-L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.as‚Ñù‚Çã"><a class="docstring-binding" href="#TransformVariables.as‚Ñù‚Çã"><code>TransformVariables.as‚Ñù‚Çã</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><section><div><p>Transform to a negative real number. See <a href="#TransformVariables.as"><code>as</code></a>.</p><p><code>as‚Ñù‚Çã</code> and <code>as_negative_real</code> are equivalent alternatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/scalar.jl#L247-L251">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.asùïÄ"><a class="docstring-binding" href="#TransformVariables.asùïÄ"><code>TransformVariables.asùïÄ</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><section><div><p>Transform to the unit interval <code>(0, 1)</code>. See <a href="#TransformVariables.as"><code>as</code></a>.</p><p><code>asùïÄ</code> and <code>as_unit_interval</code> are equivalent alternatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/scalar.jl#L256-L260">source</a></section></details></article><p>For more granular control than the <code>as(Real, a, b)</code>, scalar transformations can be built from individual elements with the composition operator <code>‚àò</code> (typed as <code>\circ&lt;tab&gt;</code>):</p><article><details class="docstring" open="true"><summary id="TransformVariables.TVExp"><a class="docstring-binding" href="#TransformVariables.TVExp"><code>TransformVariables.TVExp</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct TVExp &lt;: TransformVariables.ScalarTransform</code></pre><p>Exponential transformation <code>x ‚Ü¶ eÀ£</code>. Maps from all reals to the positive reals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/scalar.jl#L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.TVLogistic"><a class="docstring-binding" href="#TransformVariables.TVLogistic"><code>TransformVariables.TVLogistic</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct TVLogistic &lt;: TransformVariables.ScalarTransform</code></pre><p>Logistic transformation <code>x ‚Ü¶ logit(x)</code>. Maps from all reals to (0, 1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/scalar.jl#L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.TVScale"><a class="docstring-binding" href="#TransformVariables.TVScale"><code>TransformVariables.TVScale</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct TVScale{T} &lt;: TransformVariables.ScalarTransform</code></pre><p>Scale transformation <code>x ‚Ü¶ scale * x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/scalar.jl#L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.TVShift"><a class="docstring-binding" href="#TransformVariables.TVShift"><code>TransformVariables.TVShift</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct TVShift{T&lt;:Real} &lt;: TransformVariables.ScalarTransform</code></pre><p>Shift transformation <code>x ‚Ü¶ x + shift</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/scalar.jl#L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.TVNeg"><a class="docstring-binding" href="#TransformVariables.TVNeg"><code>TransformVariables.TVNeg</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct TVNeg &lt;: TransformVariables.ScalarTransform</code></pre><p>Negative transformation <code>x ‚Ü¶ -x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/scalar.jl#L138">source</a></section></details></article><p>Consistent with common notation, transforms are applied right-to-left; for example, <code>as(Real, ‚àû, 3)</code> is equivalent to <code>TVShift(3) ‚àò TVNeg() ‚àò TVExp()</code>. If you are working in an editor where typing Unicode is difficult, <code>TransformVariables.compose</code> is also available, as in <code>TransformVariables.compose(TVScale(5.0), TVNeg(), TVExp())</code>.</p><p>This composition works with any scalar transform in any order, so <code>TVScale(4) ‚àò as(Real, 2, ‚àû) ‚àò TVShift(1e3)</code> is a valid transform. This is useful especially for making sure that values near 0, when transformed, yield usefully-scaled values for a given variable.</p><p>In addition, the <code>TVScale</code> transform accepts arbitrary types. It can be used as the outermost transform (so leftmost in the composition) to add, for example, <code>Unitful</code> units to a number (or to create other exotic number types which can be constructed by multiplying, such as a <code>ForwardDiff.Dual</code>).</p><p>However, note that calculating log Jacobian determinants may error for types that are not real numbers. For example, </p><pre><code class="language-julia hljs">using Unitful
t = TVScale(5u&quot;m&quot;) ‚àò TVExp()</code></pre><p>produces positive quantities with the dimension of length. </p><div class="admonition is-info" id="Note-2d65692265ab7f62"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2d65692265ab7f62" title="Permalink"></a></header><div class="admonition-body"><p>Because the log-Jacobian of a transform that adds units is not defined, <code>transform_and_logjac</code> and <code>inverse_and_logjac</code> only have methods defined for <code>TVScale{T} where {T&lt;:Real}</code>. </p></div></div><div class="admonition is-info" id="Note-59457b23b3fb2b41"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-59457b23b3fb2b41" title="Permalink"></a></header><div class="admonition-body"><p>The inverse transform of <code>TVScale(scale)</code> divides by <code>scale</code>, which is the correct inverse for adding units to a number, but may be inappropriate for other custom number types. A transform that doesn&#39;t just multiply or an inverse that extracts a float from an exotic number type could be defined by adding methods to <code>transform</code> and <code>inverse</code> like the following: <code>transform(t::TVScale{T}, x) where T&lt;:MyCustomNumberType = MyCustomNumberType(x) inverse(t::TVScale{T}, x) where T&lt;:MyCustomNumberType = get_the_float_part(x)</code></p></div></div><h2 id="Special-arrays"><a class="docs-heading-anchor" href="#Special-arrays">Special arrays</a><a id="Special-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Special-arrays" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="TransformVariables.unit_vector_norm"><a class="docstring-binding" href="#TransformVariables.unit_vector_norm"><code>TransformVariables.unit_vector_norm</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unit_vector_norm(n; chi_prior)
</code></pre><p>Transform <code>n ‚â• 2</code> real numbers to a unit vector of length <code>n</code> and a radius, under the Euclidean norm. Returns the tuple <code>(normalized_vector, radius)</code>.</p><p>When <code>chi_prior = true</code>, a prior correction is applied to the radius, which only affects the log Jacobian determinant. The purpose of this is to make the distribution proper. If you wish to use another prior, set this to <code>false</code> and use a manual correction, see also <a href="#TransformVariables.logprior"><code>logprior</code></a>.</p><div class="admonition is-info" id="Note-e29615c50376d7b9"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e29615c50376d7b9" title="Permalink"></a></header><div class="admonition-body"><p>At the origin, this transform is non-bijective and non-differentiable. If maximizing a target distribution whose density is constant for the unit vector, then the maximizer using the Chi prior is at the origin, and behavior is undefined.</p></div></div><div class="admonition is-info" id="Note-f4062fb2b597165d"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f4062fb2b597165d" title="Permalink"></a></header><div class="admonition-body"><p>While <span>$n = 1$</span> would be technically possible, for practical purposes it would likely suffer from numerical issues, since the transform is undefined at <span>$x = 0$</span>, and for a Markov chain to travel from <span>$y=[-1]$</span> to <span>$y=[1]$</span>, it would have to leap over the origin, which is only even possible due to discretization and likely will often not work. Because of this, it is disallowed.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/special_arrays.jl#L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.UnitVector"><a class="docstring-binding" href="#TransformVariables.UnitVector"><code>TransformVariables.UnitVector</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnitVector(n)</code></pre><p>Transform <code>n-1</code> real numbers to a unit vector of length <code>n</code>, under the Euclidean norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/special_arrays.jl#L62-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.UnitSimplex"><a class="docstring-binding" href="#TransformVariables.UnitSimplex"><code>TransformVariables.UnitSimplex</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnitSimplex(n)</code></pre><p>Transform <code>n-1</code> real numbers to a vector of length <code>n</code> whose elements are non-negative and sum to one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/special_arrays.jl#L209-L213">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.CorrCholeskyFactor"><a class="docstring-binding" href="#TransformVariables.CorrCholeskyFactor"><code>TransformVariables.CorrCholeskyFactor</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CorrCholeskyFactor(n)</code></pre><div class="admonition is-info" id="Note-1fa826cad1d642eb"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1fa826cad1d642eb" title="Permalink"></a></header><div class="admonition-body"><p>It is better style to use <a href="#TransformVariables.corr_cholesky_factor"><code>corr_cholesky_factor</code></a>, this will be deprecated.</p></div></div><p>Cholesky factor of a correlation matrix of size <code>n</code>.</p><p>Transforms <span>$n√ó(n-1)/2$</span> real numbers to an <span>$n√ón$</span> upper-triangular matrix <code>U</code>, such that <code>U&#39;*U</code> is a correlation matrix (positive definite, with unit diagonal).</p><p><strong>Notes</strong></p><p>If</p><ul><li><p><code>z</code> is a vector of <code>n</code> IID standard normal variates,</p></li><li><p><code>œÉ</code> is an <code>n</code>-element vector of standard deviations,</p></li><li><p><code>U</code> is obtained from <code>CorrCholeskyFactor(n)</code>,</p></li></ul><p>then <code>Diagonal(œÉ) * U&#39; * z</code> will be a multivariate normal with the given variances and correlation matrix <code>U&#39; * U</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/special_arrays.jl#L276-L299">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.corr_cholesky_factor"><a class="docstring-binding" href="#TransformVariables.corr_cholesky_factor"><code>TransformVariables.corr_cholesky_factor</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">corr_cholesky_factor(n)
</code></pre><p>Transform into a Cholesky factor of a correlation matrix.</p><p>If the argument is a (positive) integer <code>n</code>, it determines the size of the output <code>n √ó n</code>, resulting in a <code>Matrix</code>.</p><p>If the argument is <code>SMatrix{N,N}</code>, an <code>SMatrix</code> is produced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/special_arrays.jl#L313">source</a></section></details></article><h2 id="Miscellaneous-transformations"><a class="docs-heading-anchor" href="#Miscellaneous-transformations">Miscellaneous transformations</a><a id="Miscellaneous-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous-transformations" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="TransformVariables.Constant"><a class="docstring-binding" href="#TransformVariables.Constant"><code>TransformVariables.Constant</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p><code>Constant(value)</code></p><p>Placeholder for inserting a constant. Inverse checks equality with <code>==</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/constant.jl#L7-L11">source</a></section></details></article><h1 id="Defining-custom-transformations"><a class="docs-heading-anchor" href="#Defining-custom-transformations">Defining custom transformations</a><a id="Defining-custom-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-custom-transformations" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="TransformVariables.logjac_forwarddiff"><a class="docstring-binding" href="#TransformVariables.logjac_forwarddiff"><code>TransformVariables.logjac_forwarddiff</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logjac_forwarddiff(f, x; handleNaN, chunk, cfg)
</code></pre><p>Calculate the log Jacobian determinant of <code>f</code> at <code>x</code> using <code>ForwardDiff</code>.</p><p><strong>Note</strong></p><p><code>f</code> should be a bijection, mapping from vectors of real numbers to vectors of equal length.</p><p>When <code>handleNaN = true</code> (the default), <code>NaN</code> log Jacobians are converted to <code>-Inf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/custom.jl#L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.value_and_logjac_forwarddiff"><a class="docstring-binding" href="#TransformVariables.value_and_logjac_forwarddiff"><code>TransformVariables.value_and_logjac_forwarddiff</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">value_and_logjac_forwarddiff(
    f,
    x;
    flatten,
    handleNaN,
    chunk,
    cfg
)
</code></pre><p>Calculate the value and the log Jacobian determinant of <code>f</code> at <code>x</code>. <code>flatten</code> is used to get a vector out of the result that makes <code>f</code> a bijection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/custom.jl#L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TransformVariables.CustomTransform"><a class="docstring-binding" href="#TransformVariables.CustomTransform"><code>TransformVariables.CustomTransform</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CustomTransform(g, f, flatten; chunk, cfg)
</code></pre><p>Wrap a custom transform <code>y = f(transform(g, x))</code> in a type that calculates the log Jacobian of <span>$‚àÇy/‚àÇx$</span> using <code>ForwardDiff</code> when necessary.</p><p>Usually, <code>g::TransformReals</code>, but when an integer is used, it amounts to the identity transformation with that dimension.</p><p><code>flatten</code> should take the result from <code>f</code>, and return a flat vector with no redundant elements, so that <span>$x ‚Ü¶ y$</span> is a bijection. For example, for a covariance matrix the elements below the diagonal should be removed.</p><p><code>chunk</code> and <code>cfg</code> can be used to configure <code>ForwardDiff.JacobianConfig</code>. <code>cfg</code> is used directly, while <code>chunk = ForwardDiff.Chunk{N}()</code> can be used to obtain a type-stable configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/TransformVariables.jl/blob/dcb94333e69ef851d35c61d94f35fabb0441fca2/src/custom.jl#L50">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="internals/">Internals ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 25 November 2025 08:33">Tuesday 25 November 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
