var documenterSearchIndex = {"docs":
[{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"Some problems, especially in numerical integration and Markov Chain Monte Carlo, benefit from transformation of variables: for example, if œÉ  0 is a standard deviation parameter, it is usually better to work with log(œÉ) which can take any value on the real line. However, in general such transformations require correcting density functions by the determinant of their Jacobian matrix, usually referred to as \"the Jacobian\".\n\nAlso, is usually easier to code MCMC algorithms to work with vectors of real numbers, which may represent a \"flattened\" version of parameters, and would need to be decomposed into individual parameters, which themselves may be arrays, tuples, or special objects like lower triangular matrices.\n\nThis package is designed to help with both of these use cases. For example, consider the \"8 schools\" problem from Chapter 5.5 of Gelman et al (2013), in which SAT scores y_ij in J=8 schools are modeled using a conditional normal\n\ny_ij  N(Œ∏‚±º œÉ¬≤)\n\nand the Œ∏‚±º are assume to have a hierarchical prior distribution\n\nŒ∏‚±º  N(Œº œÑ¬≤)\n\nFor this problem, one could define a transformation\n\nusing TransformVariables\nt = as((Œº = as‚Ñù, œÉ = as‚Ñù‚Çä, œÑ = as‚Ñù‚Çä, Œ∏s = as(Array, 8)))\ndimension(t)\n\nwhich would then yield a NamedTuple with the given names, with one of them being a Vector:\n\nx = randn(dimension(t))\ny = transform(t, x)\nkeys(y)\ny.Œ∏s\n\nFurther worked examples of using this package can be found in the DynamicHMCExamples.jl repository. It is recommended that the user reads those first, and treats this documentation as a reference.","category":"section"},{"location":"#General-interface","page":"Introduction","title":"General interface","text":"","category":"section"},{"location":"#Transformations","page":"Introduction","title":"Transformations","text":"","category":"section"},{"location":"#Inverses","page":"Introduction","title":"Inverses","text":"","category":"section"},{"location":"#Integration-into-Bayesian-inference","page":"Introduction","title":"Integration into Bayesian inference","text":"","category":"section"},{"location":"#Miscellaneous","page":"Introduction","title":"Miscellaneous","text":"","category":"section"},{"location":"#Defining-transformations","page":"Introduction","title":"Defining transformations","text":"","category":"section"},{"location":"#The-as-constructor-and-aggregations","page":"Introduction","title":"The as constructor and aggregations","text":"Some transformations, particularly aggregations use the function as as the constructor. Aggregating transformations are built from other transformations to transform consecutive (blocks of) real numbers into the desired domain.\n\nIt is recommended that you use as(Array, ...) and friends (as(Vector, ...), as(Matrix, ...)) for repeating the same transformation, and named tuples such as as((Œº = ..., œÉ = ...)) for transforming into named parameters. For extracting parameters in log likelihoods, consider Parameters.jl.\n\nSee methods(as) for all the constructors, ?as for their documentation.","category":"section"},{"location":"#Scalar-transforms","page":"Introduction","title":"Scalar transforms","text":"The symbol ‚àû is a placeholder for infinity. It does not correspond to Inf, but acts as a placeholder for the correct dispatch. -‚àû is valid.\n\nas(Real, a, b) defines transformations to finite and (semi-)infinite subsets of the real line, where a and b can be -‚àû and ‚àû, respectively.\n\nThe following constants are defined for common cases.\n\nFor more granular control than the as(Real, a, b), scalar transformations can be built from individual elements with the composition operator ‚àò (typed as \\circ<tab>):\n\nConsistent with common notation, transforms are applied right-to-left; for example, as(Real, ‚àû, 3) is equivalent to TVShift(3) ‚àò TVNeg() ‚àò TVExp(). If you are working in an editor where typing Unicode is difficult, TransformVariables.compose is also available, as in TransformVariables.compose(TVScale(5.0), TVNeg(), TVExp()).\n\nThis composition works with any scalar transform in any order, so TVScale(4) ‚àò as(Real, 2, ‚àû) ‚àò TVShift(1e3) is a valid transform. This is useful especially for making sure that values near 0, when transformed, yield usefully-scaled values for a given variable.\n\nIn addition, the TVScale transform accepts arbitrary types. It can be used as the outermost transform (so leftmost in the composition) to add, for example, Unitful units to a number (or to create other exotic number types which can be constructed by multiplying, such as a ForwardDiff.Dual).\n\nHowever, note that calculating log Jacobian determinants may error for types that are not real numbers. For example, \n\nusing Unitful\nt = TVScale(5u\"m\") ‚àò TVExp()\n\nproduces positive quantities with the dimension of length. \n\nnote: Note\nBecause the log-Jacobian of a transform that adds units is not defined, transform_and_logjac and inverse_and_logjac only have methods defined for TVScale{T} where {T<:Real}. \n\nnote: Note\nThe inverse transform of TVScale(scale) divides by scale, which is the correct inverse for adding units to a number, but may be inappropriate for other custom number types. A transform that doesn't just multiply or an inverse that extracts a float from an exotic number type could be defined by adding methods to transform and inverse like the following: transform(t::TVScale{T}, x) where T<:MyCustomNumberType = MyCustomNumberType(x) inverse(t::TVScale{T}, x) where T<:MyCustomNumberType = get_the_float_part(x)","category":"section"},{"location":"#Special-arrays","page":"Introduction","title":"Special arrays","text":"","category":"section"},{"location":"#Miscellaneous-transformations","page":"Introduction","title":"Miscellaneous transformations","text":"","category":"section"},{"location":"#Defining-custom-transformations","page":"Introduction","title":"Defining custom transformations","text":"","category":"section"},{"location":"#TransformVariables.dimension","page":"Introduction","title":"TransformVariables.dimension","text":"dimension(t::AbstractTransform)\n\nThe dimension (number of elements) that t transforms.\n\nTypes should implement this method.\n\n\n\n\n\n","category":"function"},{"location":"#TransformVariables.transform","page":"Introduction","title":"TransformVariables.transform","text":"transform(t, x)\n\nTransform x using t.\n\ntransform(t)\n\nReturn a callable equivalent to x -> transform(t, x) that transforms its argument:\n\ntransform(t, x) == transform(t)(x)\n\n\n\n\n\n","category":"function"},{"location":"#TransformVariables.transform_and_logjac","page":"Introduction","title":"TransformVariables.transform_and_logjac","text":"transform_and_logjac(t, x)\n\n\nTransform x using t; calculating the log Jacobian determinant, returned as the second value.\n\n\n\n\n\n","category":"function"},{"location":"#TransformVariables.inverse","page":"Introduction","title":"TransformVariables.inverse","text":"inverse(t, y)\n\nReturn x so that transform(t, x) ‚âà y.\n\ninverse(t)\n\nReturn a callable equivalent to y -> inverse(t, y). t can also be a callable created with transform, so the following holds:\n\ninverse(t)(y) == inverse(t, y) == inverse(transform(t))(y)\n\nnote: Note\neltype(inverse(t, transform(t, x))) is not necessarily equal to eltype(x), it is not guaranteed to be the narrowest possible type, and may change without warning between versions. Some effort is made to come up with a reasonable concrete type even in corner cases.\n\n\n\n\n\n","category":"function"},{"location":"#TransformVariables.inverse!","page":"Introduction","title":"TransformVariables.inverse!","text":"inverse!(x, transformation, y)\n\n\nPut inverse(t, y) into a preallocated vector x, returning x.\n\nGeneralized indexing should be assumed on x.\n\nSee inverse_eltype for determining the type of x.\n\n\n\n\n\n","category":"function"},{"location":"#TransformVariables.inverse_eltype","page":"Introduction","title":"TransformVariables.inverse_eltype","text":"inverse_eltype(t::AbstractTransform, y)\ninverse_eltype(t::AbstractTransform, ::Type{T})\n\nThe element type for vector x so that inverse!(x, t, y::T) works.\n\nNotes\n\nIt is not guaranteed that the result is the narrowest possible type, and may change without warning between versions. Some effort is made to come up with a reasonable concrete type even in corner cases.\nTransformations should provide a method for types, not values.\nNo dimension or input compatibility checks are guaranteed to be performed, even for values.\n\n\n\n\n\n","category":"function"},{"location":"#TransformVariables.transform_logdensity","page":"Introduction","title":"TransformVariables.transform_logdensity","text":"transform_logdensity(t, f, x)\n\n\nLet y = t(x), and f(y) a log density at y. This function evaluates f ‚àò t as a log density, taking care of the log Jacobian correction.\n\n\n\n\n\n","category":"function"},{"location":"#TransformVariables.logprior","page":"Introduction","title":"TransformVariables.logprior","text":"logprior(t, y)\n\n\nReturn the log prior correction used in transform_and_logjac. The second argument is the output of a transformation.\n\nThe log jacobian determinant is corrected by this value, usually for the purpose of making a distribution proper. Can only be nonzero when nonzero_logprior is true.\n\n\n\n\n\n","category":"function"},{"location":"#TransformVariables.nonzero_logprior","page":"Introduction","title":"TransformVariables.nonzero_logprior","text":"nonzero_logprior(t)\n\n\nReturn true only if there are potential inputs for which logprior is nonzero.\n\nnote: Note\nCurrently the only transformation that has a log prior correction is unit_vector_norm.\n\n\n\n\n\n","category":"function"},{"location":"#TransformVariables.domain_label","page":"Introduction","title":"TransformVariables.domain_label","text":"domain_label(transformation, index)\n\n\nReturn a string that can be used to for identifying a coordinate. Mainly for debugging and generating graphs and data summaries.\n\nTransformations may provide a heuristic label.\n\nTransformations should implement _domain_label.\n\nExample\n\njulia> t = as((a = as‚Ñù‚Çä,\n            b = as(Array, as‚Ñù‚Çã, 1, 1),\n            c = corr_cholesky_factor(2)));\n\njulia> [domain_label(t, i) for i in 1:dimension(t)]\n3-element Vector{String}:\n \".a\"\n \".b[1,1]\"\n \".c[1]\"\n\n\n\n\n\n","category":"function"},{"location":"#TransformVariables.as","page":"Introduction","title":"TransformVariables.as","text":"as(T, args...)\n\nShorthand for constructing transformations with image in T. args determines or modifies behavior, details depend on T.\n\nNot all transformations have an as method, some just have direct constructors. See methods(as) for a list.\n\nExamples\n\nas(Real, -‚àû, 1)          # transform a real number to (-‚àû, 1)\nas(Array, 10, 2)         # reshape 20 real numbers to a 10x2 matrix\nas(Array, asùïÄ, 10)       # transform 10 real numbers to (0, 1)\nas((a = as‚Ñù‚Çä, b = asùïÄ)) # transform 2 real numbers a NamedTuple, with a > 0, 0 < b < 1\nas(SArray{1,2,3}, asùïÄ)  # transform to a static array of positive numbers\n\n\n\n\n\n","category":"function"},{"location":"#TransformVariables.‚àû","page":"Introduction","title":"TransformVariables.‚àû","text":"Placeholder representing of infinity for specifing interval boundaries. Supports the - operator, ie -‚àû.\n\n\n\n\n\n","category":"constant"},{"location":"#TransformVariables.as-Tuple{Type{Real}, Any, Any}","page":"Introduction","title":"TransformVariables.as","text":"as(Real, left, right)\n\nReturn a transformation that transforms a single real number to the given (open) interval.\n\nleft < right is required, but may be -‚àû or ‚àû, respectively, in which case the appropriate transformation is selected. See ‚àû.\n\nSome common transformations are predefined as constants, see as‚Ñù, as‚Ñù‚Çã, as‚Ñù‚Çä, asùïÄ.\n\nnote: Note\nThe finite arguments are promoted to a common type and affect promotion. Eg transform(as(0, ‚àû), 0f0) isa Float32, but transform(as(0.0, ‚àû), 0f0) isa Float64.\n\n\n\n\n\n","category":"method"},{"location":"#TransformVariables.as‚Ñù","page":"Introduction","title":"TransformVariables.as‚Ñù","text":"Transform to the real line (identity). See as.\n\nas‚Ñù and as_real are equivalent alternatives.\n\n\n\n\n\n","category":"constant"},{"location":"#TransformVariables.as‚Ñù‚Çä","page":"Introduction","title":"TransformVariables.as‚Ñù‚Çä","text":"Transform to a positive real number. See as.\n\nas‚Ñù‚Çä and as_positive_real are equivalent alternatives.\n\n\n\n\n\n","category":"constant"},{"location":"#TransformVariables.as‚Ñù‚Çã","page":"Introduction","title":"TransformVariables.as‚Ñù‚Çã","text":"Transform to a negative real number. See as.\n\nas‚Ñù‚Çã and as_negative_real are equivalent alternatives.\n\n\n\n\n\n","category":"constant"},{"location":"#TransformVariables.asùïÄ","page":"Introduction","title":"TransformVariables.asùïÄ","text":"Transform to the unit interval (0, 1). See as.\n\nasùïÄ and as_unit_interval are equivalent alternatives.\n\n\n\n\n\n","category":"constant"},{"location":"#TransformVariables.TVExp","page":"Introduction","title":"TransformVariables.TVExp","text":"struct TVExp <: TransformVariables.ScalarTransform\n\nExponential transformation x ‚Ü¶ eÀ£. Maps from all reals to the positive reals.\n\n\n\n\n\n","category":"type"},{"location":"#TransformVariables.TVLogistic","page":"Introduction","title":"TransformVariables.TVLogistic","text":"struct TVLogistic <: TransformVariables.ScalarTransform\n\nLogistic transformation x ‚Ü¶ logit(x). Maps from all reals to (0, 1).\n\n\n\n\n\n","category":"type"},{"location":"#TransformVariables.TVScale","page":"Introduction","title":"TransformVariables.TVScale","text":"struct TVScale{T} <: TransformVariables.ScalarTransform\n\nScale transformation x ‚Ü¶ scale * x.\n\n\n\n\n\n","category":"type"},{"location":"#TransformVariables.TVShift","page":"Introduction","title":"TransformVariables.TVShift","text":"struct TVShift{T<:Real} <: TransformVariables.ScalarTransform\n\nShift transformation x ‚Ü¶ x + shift.\n\n\n\n\n\n","category":"type"},{"location":"#TransformVariables.TVNeg","page":"Introduction","title":"TransformVariables.TVNeg","text":"struct TVNeg <: TransformVariables.ScalarTransform\n\nNegative transformation x ‚Ü¶ -x.\n\n\n\n\n\n","category":"type"},{"location":"#TransformVariables.unit_vector_norm","page":"Introduction","title":"TransformVariables.unit_vector_norm","text":"unit_vector_norm(n; chi_prior)\n\n\nTransform n ‚â• 2 real numbers to a unit vector of length n and a radius, under the Euclidean norm. Returns the tuple (normalized_vector, radius).\n\nWhen chi_prior = true, a prior correction is applied to the radius, which only affects the log Jacobian determinant. The purpose of this is to make the distribution proper. If you wish to use another prior, set this to false and use a manual correction, see also logprior.\n\nnote: Note\nAt the origin, this transform is non-bijective and non-differentiable. If maximizing a target distribution whose density is constant for the unit vector, then the maximizer using the Chi prior is at the origin, and behavior is undefined.\n\nnote: Note\nWhile n = 1 would be technically possible, for practical purposes it would likely suffer from numerical issues, since the transform is undefined at x = 0, and for a Markov chain to travel from y=-1 to y=1, it would have to leap over the origin, which is only even possible due to discretization and likely will often not work. Because of this, it is disallowed.\n\n\n\n\n\n","category":"function"},{"location":"#TransformVariables.UnitVector","page":"Introduction","title":"TransformVariables.UnitVector","text":"UnitVector(n)\n\nTransform n-1 real numbers to a unit vector of length n, under the Euclidean norm.\n\n\n\n\n\n","category":"type"},{"location":"#TransformVariables.UnitSimplex","page":"Introduction","title":"TransformVariables.UnitSimplex","text":"UnitSimplex(n)\n\nTransform n-1 real numbers to a vector of length n whose elements are non-negative and sum to one.\n\n\n\n\n\n","category":"type"},{"location":"#TransformVariables.CorrCholeskyFactor","page":"Introduction","title":"TransformVariables.CorrCholeskyFactor","text":"CorrCholeskyFactor(n)\n\nnote: Note\nIt is better style to use corr_cholesky_factor, this will be deprecated.\n\nCholesky factor of a correlation matrix of size n.\n\nTransforms n(n-1)2 real numbers to an nn upper-triangular matrix U, such that U'*U is a correlation matrix (positive definite, with unit diagonal).\n\nNotes\n\nIf\n\nz is a vector of n IID standard normal variates,\nœÉ is an n-element vector of standard deviations,\nU is obtained from CorrCholeskyFactor(n),\n\nthen Diagonal(œÉ) * U' * z will be a multivariate normal with the given variances and correlation matrix U' * U.\n\n\n\n\n\n","category":"type"},{"location":"#TransformVariables.corr_cholesky_factor","page":"Introduction","title":"TransformVariables.corr_cholesky_factor","text":"corr_cholesky_factor(n)\n\n\nTransform into a Cholesky factor of a correlation matrix.\n\nIf the argument is a (positive) integer n, it determines the size of the output n √ó n, resulting in a Matrix.\n\nIf the argument is SMatrix{N,N}, an SMatrix is produced.\n\n\n\n\n\n","category":"function"},{"location":"#TransformVariables.Constant","page":"Introduction","title":"TransformVariables.Constant","text":"Constant(value)\n\nPlaceholder for inserting a constant. Inverse checks equality with ==.\n\n\n\n\n\n","category":"type"},{"location":"#TransformVariables.logjac_forwarddiff","page":"Introduction","title":"TransformVariables.logjac_forwarddiff","text":"logjac_forwarddiff(f, x; handleNaN, chunk, cfg)\n\n\nCalculate the log Jacobian determinant of f at x using ForwardDiff.\n\nNote\n\nf should be a bijection, mapping from vectors of real numbers to vectors of equal length.\n\nWhen handleNaN = true (the default), NaN log Jacobians are converted to -Inf.\n\n\n\n\n\n","category":"function"},{"location":"#TransformVariables.value_and_logjac_forwarddiff","page":"Introduction","title":"TransformVariables.value_and_logjac_forwarddiff","text":"value_and_logjac_forwarddiff(\n    f,\n    x;\n    flatten,\n    handleNaN,\n    chunk,\n    cfg\n)\n\n\nCalculate the value and the log Jacobian determinant of f at x. flatten is used to get a vector out of the result that makes f a bijection.\n\n\n\n\n\n","category":"function"},{"location":"#TransformVariables.CustomTransform","page":"Introduction","title":"TransformVariables.CustomTransform","text":"CustomTransform(g, f, flatten; chunk, cfg)\n\n\nWrap a custom transform y = f(transform(g, x)) in a type that calculates the log Jacobian of yx using ForwardDiff when necessary.\n\nUsually, g::TransformReals, but when an integer is used, it amounts to the identity transformation with that dimension.\n\nflatten should take the result from f, and return a flat vector with no redundant elements, so that x  y is a bijection. For example, for a covariance matrix the elements below the diagonal should be removed.\n\nchunk and cfg can be used to configure ForwardDiff.JacobianConfig. cfg is used directly, while chunk = ForwardDiff.Chunk{N}() can be used to obtain a type-stable configuration.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#Types-for-various-transformations","page":"Internals","title":"Types for various transformations","text":"These are not part of the API, use the as constructor or one of the predefined constants.","category":"section"},{"location":"internals/#Scalar-transformations","page":"Internals","title":"Scalar transformations","text":"","category":"section"},{"location":"internals/#Aggregating-transformations","page":"Internals","title":"Aggregating transformations","text":"","category":"section"},{"location":"internals/#Wrapper-for-inverse","page":"Internals","title":"Wrapper for inverse","text":"","category":"section"},{"location":"internals/#Types-and-type-aliases","page":"Internals","title":"Types and type aliases","text":"","category":"section"},{"location":"internals/#Conditional-calculation-of-log-Jacobian-determinant","page":"Internals","title":"Conditional calculation of log Jacobian determinant","text":"","category":"section"},{"location":"internals/#Helper-functions","page":"Internals","title":"Helper functions","text":"","category":"section"},{"location":"internals/#Building-blocks-for-transformations","page":"Internals","title":"Building blocks for transformations","text":"","category":"section"},{"location":"internals/#TransformVariables.Identity","page":"Internals","title":"TransformVariables.Identity","text":"struct Identity <: TransformVariables.ScalarTransform\n\nIdentity x  x.\n\n\n\n\n\n","category":"type"},{"location":"internals/#TransformVariables.ArrayTransformation","page":"Internals","title":"TransformVariables.ArrayTransformation","text":"struct ArrayTransformation{T<:TransformVariables.AbstractTransform, M} <: TransformVariables.VectorTransform\n\nApply transformation repeatedly to create an array with given dims.\n\n\n\n\n\n","category":"type"},{"location":"internals/#TransformVariables.TransformTuple","page":"Internals","title":"TransformVariables.TransformTuple","text":"struct TransformTuple{T} <: TransformVariables.VectorTransform\n\nTransform consecutive groups of real numbers to a tuple, using the given transformations.\n\n\n\n\n\n","category":"type"},{"location":"internals/#TransformVariables.CallableInverse","page":"Internals","title":"TransformVariables.CallableInverse","text":"struct Fix1{typeof(inverse), T<:TransformVariables.AbstractTransform} <: Function\n\nPartial application of inverse(t, y), callable with y. Use inverse(t) to construct.\n\n\n\n\n\n","category":"type"},{"location":"internals/#TransformVariables.AbstractTransform","page":"Internals","title":"TransformVariables.AbstractTransform","text":"abstract type AbstractTransform\n\nSupertype for all transformations in this package.\n\nUsed for internal code organization and documenting the interface. Transformations (potentially defined outside this package) do not need to be a subtype.\n\nInterface\n\nThe user interface consists of\n\ndimension\ntransform\ntransform_and_logjac\ninverse, inverse!\ninverse_eltype.\nnonzero_logprior.\nlogprior\n\n\n\n\n\n","category":"type"},{"location":"internals/#TransformVariables.ScalarTransform","page":"Internals","title":"TransformVariables.ScalarTransform","text":"abstract type ScalarTransform <: TransformVariables.AbstractTransform\n\nTransform a scalar (real number) to another scalar.\n\nSubtypes must define transform, transform_and_logjac, and inverse. Other methods of of the interface should have the right defaults.\n\nnote: Note\nThis type is for code organization within the package, and is not part of the public API.\n\n\n\n\n\n","category":"type"},{"location":"internals/#TransformVariables.VectorTransform","page":"Internals","title":"TransformVariables.VectorTransform","text":"abstract type VectorTransform <: TransformVariables.AbstractTransform\n\nTransformation that transforms <: AbstractVectors to other values.\n\nImplementation\n\nImplements transform and transform_and_logjac via transform_with, and inverse via inverse!.\n\n\n\n\n\n","category":"type"},{"location":"internals/#TransformVariables.LogJacFlag","page":"Internals","title":"TransformVariables.LogJacFlag","text":"abstract type LogJacFlag\n\nFlag used internally by the implementation of transformations, as explained below.\n\nWhen calculating the log jacobian determinant for a matrix, initialize with\n\nlogjac_zero(flag, x)\n\nand then accumulate with log jacobians as needed with +.\n\nWhen flag is LogJac, methods should return the log Jacobian as the second argument, otherwise NoLogJac, which simply combines to itself with +, serving as an empty placeholder. This allows methods to share code of the two implementations.\n\n\n\n\n\n","category":"type"},{"location":"internals/#TransformVariables.LogJac","page":"Internals","title":"TransformVariables.LogJac","text":"struct LogJac <: TransformVariables.LogJacFlag\n\nCalculate log Jacobian as the second value.\n\n\n\n\n\n","category":"type"},{"location":"internals/#TransformVariables.NoLogJac","page":"Internals","title":"TransformVariables.NoLogJac","text":"struct NoLogJac <: TransformVariables.LogJacFlag\n\nDon't calculate log Jacobian, return NOLOGJAC as the second value.\n\n\n\n\n\n","category":"type"},{"location":"internals/#TransformVariables.logjac_zero","page":"Internals","title":"TransformVariables.logjac_zero","text":"logjac_zero(_, _)\n\n\nInitial value for log Jacobian calculations.\n\n\n\n\n\n","category":"function"},{"location":"internals/#TransformVariables.transform_with","page":"Internals","title":"TransformVariables.transform_with","text":"transform_with(flag::LogJacFlag, transformation, x::AbstractVector, index)\n\nTransform elements of x from index, using transformation.\n\nReturn (y, logjac), index‚Ä≤, where\n\ny is the result of the transformation,\nlogjac is the the log Jacobian determinant or a placeholder, depending on flag,\nindex‚Ä≤ is the next index in x after the elements used for the transformation\n\nInternal function. Implementations\n\ncan assume that x has enough elements for transformation (ie @inbounds can be used),\nshould work with generalized indexing on x.\n\n\n\n\n\n","category":"function"},{"location":"internals/#TransformVariables._transform_tuple","page":"Internals","title":"TransformVariables._transform_tuple","text":"_transform_tuple(flag, x, index, _)\n\n\nHelper function for transforming tuples. Used internally, to help type inference. Use via transfom_tuple.\n\n\n\n\n\n","category":"function"},{"location":"internals/#TransformVariables._inverse!_tuple","page":"Internals","title":"TransformVariables._inverse!_tuple","text":"_inverse!_tuple(x, index, ts, ys)\n\n\nHelper function for inverting tuples of transformations. Used internally.\n\nPerforms no argument validation, caller should do this.\n\n\n\n\n\n","category":"function"},{"location":"internals/#TransformVariables._inverse_eltype_tuple","page":"Internals","title":"TransformVariables._inverse_eltype_tuple","text":"_inverse_eltype_tuple(ts, _)\n\n\nHelper function determining element type of inverses from tuples. Used internally.\n\nPerforms no argument validation, caller should do this.\n\n\n\n\n\n","category":"function"},{"location":"internals/#TransformVariables.unit_triangular_dimension","page":"Internals","title":"TransformVariables.unit_triangular_dimension","text":"unit_triangular_dimension(n)\n\n\nNumber of elements (strictly) above the diagonal in an nn matrix.\n\n\n\n\n\n","category":"function"},{"location":"internals/#TransformVariables.l2_remainder_transform","page":"Internals","title":"TransformVariables.l2_remainder_transform","text":"(y, log_r, ‚Ñì) = l2_remainder_transform(flag, x, log_r)\n\nGiven x  ‚Ñù and 0  r  1, we define (y, r‚Ä≤) such that\n\ny¬≤ + (r)¬≤ = r¬≤,\ny y  r is mapped with a bijection from x, with the sign depending on x,\n\nbut use log(r) for actual calculations so that large ys still give nonsingular results.\n\n‚Ñì is the log Jacobian (whether it is evaluated depends on flag).\n\n\n\n\n\n","category":"function"},{"location":"internals/#TransformVariables.l2_remainder_inverse","page":"Internals","title":"TransformVariables.l2_remainder_inverse","text":"(x, r‚Ä≤) = l2_remainder_inverse(y, log_r)\n\nInverse of l2_remainder_transform in x and y.\n\n\n\n\n\n","category":"function"}]
}
